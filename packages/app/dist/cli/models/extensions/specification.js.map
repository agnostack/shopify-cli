{"version":3,"file":"specification.js","sourceRoot":"","sources":["../../../../src/cli/models/extensions/specification.ts"],"names":[],"mappings":"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","sourcesContent":["import {ZodSchemaType, BaseConfigType, BaseSchema} from './schemas.js'\nimport {FunctionConfigType} from './specifications/function.js'\nimport {ExtensionFlavor} from '../app/extensions.js'\nimport {blocks, defaultExtensionFlavors} from '../../constants.js'\nimport {ok, Result} from '@shopify/cli-kit/node/result'\nimport {capitalize, constantize} from '@shopify/cli-kit/common/string'\nimport {randomUUID} from '@shopify/cli-kit/node/crypto'\nimport {partnersFqdn} from '@shopify/cli-kit/node/context/fqdn'\nimport {joinPath, basename} from '@shopify/cli-kit/node/path'\nimport {outputContent, outputToken, TokenizedString} from '@shopify/cli-kit/node/output'\n\nexport type ExtensionFeature = 'ui' | 'ui_legacy' | 'function' | 'theme' | 'bundling' | 'cart_url'\n\n/**\n * Extension specification with all the needed properties and methods to load an extension.\n */\nexport interface ExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType> {\n  identifier: string\n  externalIdentifier: string\n  externalName: string\n  group?: string\n  additionalIdentifiers: string[]\n  partnersWebIdentifier: string\n  surface: string\n  singleEntryPath: boolean\n  registrationLimit: number\n  supportedFlavors: ExtensionFlavor[]\n  gated: boolean\n  helpURL?: string\n  dependency?: string\n  graphQLType?: string\n  schema: ZodSchemaType<TConfiguration>\n  getBundleExtensionStdinContent?: (config: TConfiguration) => string\n  deployConfig?: (config: TConfiguration, directory: string) => Promise<{[key: string]: unknown}>\n  validate?: (config: TConfiguration, directory: string) => Promise<Result<unknown, string>>\n  preDeployValidation?: (extension: ExtensionInstance<TConfiguration>) => Promise<void>\n  buildValidation?: (extension: ExtensionInstance<TConfiguration>) => Promise<void>\n  previewMessage?: (\n    host: string,\n    uuid: string,\n    config: TConfiguration,\n    storeFqdn: string,\n  ) => TokenizedString | undefined\n  shouldFetchCartUrl?(config: TConfiguration): boolean\n  hasExtensionPointTarget?(config: TConfiguration, target: string): boolean\n  appModuleFeatures: (config: TConfiguration) => ExtensionFeature[]\n  isPreviewable: boolean\n}\n\n/**\n * Class that represents an instance of a local extension\n * Before creating this class we've validated that:\n * - There is a spec for this type of extension\n * - The Schema for that spec is followed by the extension config toml file\n * - We were able to find an entry point file for that extension\n *\n * It supports extension points, making this Class compatible with both new ui-extension\n * and legacy extension types. Extension points are optional and this class will handle them if present.\n *\n * This class holds the public interface to interact with extensions\n */\nexport class ExtensionInstance<TConfiguration extends BaseConfigType = BaseConfigType> {\n  entrySourceFilePath: string\n  devUUID: string\n  localIdentifier: string\n  idEnvironmentVariableName: string\n  directory: string\n  configuration: TConfiguration\n  configurationPath: string\n  outputBundlePath: string\n\n  private useExtensionsFramework: boolean\n  private specification: ExtensionSpecification\n\n  get graphQLType() {\n    if (this.features.includes('function')) {\n      if (this.useExtensionsFramework) return 'FUNCTION'\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const functionConfig: any = this.configuration\n      return functionConfig.type.toUpperCase()\n    }\n    return (this.specification.graphQLType ?? this.specification.identifier).toUpperCase()\n  }\n\n  get type() {\n    return this.configuration.type\n  }\n\n  get humanName() {\n    return this.specification.externalName\n  }\n\n  get name() {\n    return this.configuration.name\n  }\n\n  get dependency() {\n    return this.specification.dependency\n  }\n\n  get externalType() {\n    return this.specification.externalIdentifier\n  }\n\n  get surface() {\n    return this.specification.surface\n  }\n\n  get isPreviewable() {\n    return this.specification.isPreviewable\n  }\n\n  get features(): ExtensionFeature[] {\n    return this.specification.appModuleFeatures(this.configuration)\n  }\n\n  set usingExtensionsFramework(value: boolean) {\n    this.useExtensionsFramework = value\n  }\n\n  constructor(options: {\n    configuration: TConfiguration\n    configurationPath: string\n    entryPath?: string\n    directory: string\n    specification: ExtensionSpecification\n  }) {\n    this.configuration = options.configuration\n    this.configurationPath = options.configurationPath\n    this.entrySourceFilePath = options.entryPath ?? ''\n    this.directory = options.directory\n    this.specification = options.specification\n    this.devUUID = `dev-${randomUUID()}`\n    this.localIdentifier = basename(options.directory)\n    this.idEnvironmentVariableName = `SHOPIFY_${constantize(basename(this.directory))}_ID`\n    this.useExtensionsFramework = false\n    if (this.specification.identifier === 'theme') {\n      this.outputBundlePath = this.directory\n    } else {\n      this.outputBundlePath = joinPath(this.directory, 'dist/main.js')\n    }\n  }\n\n  deployConfig(): Promise<{[key: string]: unknown}> {\n    return this.specification.deployConfig?.(this.configuration, this.directory) ?? Promise.resolve({})\n  }\n\n  validate() {\n    if (!this.specification.validate) return Promise.resolve(ok(undefined))\n    return this.specification.validate(this.configuration, this.directory)\n  }\n\n  preDeployValidation(): Promise<void> {\n    if (!this.specification.preDeployValidation) return Promise.resolve()\n    return this.specification.preDeployValidation(this)\n  }\n\n  buildValidation(): Promise<void> {\n    if (!this.specification.buildValidation) return Promise.resolve()\n    return this.specification.buildValidation(this)\n  }\n\n  async publishURL(options: {orgId: string; appId: string; extensionId?: string}) {\n    const fqdn = await partnersFqdn()\n    const parnersPath = this.specification.partnersWebIdentifier\n    return `https://${fqdn}/${options.orgId}/apps/${options.appId}/extensions/${parnersPath}/${options.extensionId}`\n  }\n\n  previewMessage(url: string, storeFqdn: string) {\n    const heading = outputToken.heading(`${this.name} (${this.humanName})`)\n    let message = outputContent`Preview link: ${url}/extensions/${this.devUUID}`\n\n    if (this.specification.previewMessage) {\n      const customMessage = this.specification.previewMessage(url, this.devUUID, this.configuration, storeFqdn)\n      if (!customMessage) return\n      message = customMessage\n    }\n\n    return outputContent`${heading}\\n${message.value}\\n`\n  }\n\n  // UI Specific properties\n  getBundleExtensionStdinContent() {\n    if (this.specification.getBundleExtensionStdinContent) {\n      return this.specification.getBundleExtensionStdinContent(this.configuration)\n    }\n    const relativeImportPath = this.entrySourceFilePath?.replace(this.directory, '')\n    return `import '.${relativeImportPath}';`\n  }\n\n  shouldFetchCartUrl(): boolean {\n    return this.specification.shouldFetchCartUrl?.(this.configuration) || false\n  }\n\n  hasExtensionPointTarget(target: string): boolean {\n    return this.specification.hasExtensionPointTarget?.(this.configuration, target) || false\n  }\n\n  // Functions specific properties\n  get buildCommand() {\n    const config = this.configuration as unknown as FunctionConfigType\n    return config.build.command\n  }\n\n  get buildWasmPath() {\n    const config = this.configuration as unknown as FunctionConfigType\n    return joinPath(this.directory, config.build.path ?? joinPath('dist', 'index.wasm'))\n  }\n\n  get inputQueryPath() {\n    return joinPath(this.directory, 'input.graphql')\n  }\n\n  get isJavaScript() {\n    return Boolean(this.entrySourceFilePath?.endsWith('.js') || this.entrySourceFilePath?.endsWith('.ts'))\n  }\n}\n\n/**\n * These fields are forbidden when creating a new ExtensionSpec\n * They belong to the ExtensionSpec interface, but the values are obtained from the API\n * and should not be set by the user locally\n *\n * WARNING: 'surface' should be included here but is not yet compatible with the extension server\n */\nexport type ForbiddenFields = 'registrationLimit' | 'category' | 'externalIdentifier' | 'externalName' | 'name'\n\n/**\n * Partial ExtensionSpec type used when creating a new ExtensionSpec, the only mandatory field is the identifier\n */\nexport interface CreateExtensionSpecType<TConfiguration extends BaseConfigType = BaseConfigType>\n  extends Partial<Omit<ExtensionSpecification<TConfiguration>, ForbiddenFields>> {\n  identifier: string\n  appModuleFeatures: (config: TConfiguration) => ExtensionFeature[]\n}\n\n/**\n * Create a new ui extension spec.\n *\n * Everything but \"identifer\" is optional.\n * ```ts\n * identifier: string // unique identifier for the extension type\n * externalIdentifier: string // identifier used externally (default: same as \"identifier\")\n * partnersWebIdentifier: string // identifier used in the partners web UI (default: same as \"identifier\")\n * surface?: string // surface where the extension is going to be rendered (default: 'unknown')\n * singleEntryPath: boolean // whether the extension has a single entry point (default: true)\n * supportedFlavors: {name: string; value: string}[] // list of supported flavors (default: 'javascript', 'typescript', 'typescript-react', 'javascript-react')\n * helpURL?: string // url to the help page for the extension, shown after generating the extension\n * dependency?: {name: string; version: string} // dependency to be added to the extension's package.json\n * graphQLType?: string // GraphQL type of the extension (default: same as \"identifier\")\n * schema?: ZodSchemaType<TConfiguration> // schema used to validate the extension's configuration (default: BaseUIExtensionSchema)\n * getBundleExtensionStdinContent?: (configuration: TConfiguration) => string // function to generate the content of the stdin file used to bundle the extension\n * validate?: (configuration: TConfiguration, directory: string) => Promise<Result<undefined, Error>> // function to validate the extension's configuration\n * preDeployValidation?: (configuration: TConfiguration) => Promise<void> // function to validate the extension's configuration before deploying it\n * deployConfig?: (configuration: TConfiguration, directory: string) => Promise<{[key: string]: unknown}> // function to generate the extensions configuration payload to be deployed\n * previewMessage?: (url: string, devUUID: string, configuration: TConfiguration, storeFqdn: string) => string | undefined // function to generate the preview message shown to the user during `dev`\n * shouldFetchCartUrl?: (configuration: TConfiguration) => boolean // function to determine if the extension should fetch the cart url\n * hasExtensionPointTarget?: (configuration: TConfiguration, target: string) => boolean // function to determine if the extension has a given extension point target\n * ```\n */\nexport function createExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType>(\n  spec: CreateExtensionSpecType<TConfiguration>,\n): ExtensionSpecification<TConfiguration> {\n  const defaults = {\n    // these two fields are going to be overridden by the extension specification API response,\n    // but we need them to have a default value for tests\n    externalIdentifier: `${spec.identifier}_external`,\n    additionalIdentifiers: [],\n    externalName: capitalize(spec.identifier.replace(/_/g, ' ')),\n    surface: 'unknown',\n    partnersWebIdentifier: spec.identifier,\n    singleEntryPath: true,\n    gated: false,\n    schema: BaseSchema as ZodSchemaType<TConfiguration>,\n    registrationLimit: blocks.extensions.defaultRegistrationLimit,\n    supportedFlavors: defaultExtensionFlavors,\n    isPreviewable: false,\n  }\n  return {...defaults, ...spec}\n}\n"]}